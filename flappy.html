<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üïπÔ∏è Flappy Neon ‚Äî NEON ARCADE</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">

<style>
  :root{
    --pink:#ff2dfb;
    --cyan:#00eaff;
    --magenta:#d100d1;
    --bg:#050014;
    --panel: rgba(0,0,0,0.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);font-family:'Press Start 2P',monospace;color:var(--cyan);-webkit-font-smoothing:antialiased}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:18px}
  header{text-align:center;margin-top:6px}
  header h1{color:var(--pink);font-size:1.6rem;margin:6px;text-shadow:0 0 8px var(--pink),0 0 20px var(--magenta)}
  header h2{font-family:'VT323';color:var(--cyan);font-size:0.9rem;margin:0 0 12px;text-shadow:0 0 6px var(--cyan)}
  #gameCanvas{ background: linear-gradient(180deg, rgba(5,0,30,1) 0%, rgba(8,0,60,1) 60%); display:block; border-radius:12px; box-shadow: 0 0 30px rgba(0,234,255,0.07), 0 0 60px rgba(209,0,209,0.04); }

  .hud{ width:100%; max-width:420px; display:flex; justify-content:space-between; align-items:center; margin-top:10px; color:var(--cyan); }
  .btn{ background:transparent; border:1px solid var(--pink); color:var(--pink); padding:8px 10px; border-radius:8px; cursor:pointer; text-decoration:none; font-family:'VT323'; text-align:center }
  .btn:hover{ background:var(--pink); color:#000; box-shadow:0 0 18px var(--pink)}
  footer{margin-top:10px;color:var(--pink);font-family:'VT323';text-shadow:0 0 8px var(--pink)}

  .crt{ position:fixed; inset:0; pointer-events:none; background: repeating-linear-gradient(rgba(255,255,255,0.02) 0, rgba(0,0,0,0.04) 2px); }

  /* mobile scaling */
  @media (max-width:500px){
    #gameCanvas{ width: 360px; height: 540px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>NEON ARCADE</h1>
      <h2>Flappy Neon ‚Äî Cidade Futurista</h2>
    </header>

    <canvas id="gameCanvas" width="400" height="600" aria-label="Flappy Neon"></canvas>

    <div class="hud" style="max-width:400px;">
      <div id="scoreBox">SCORE: 0</div>
      <div style="display:flex;gap:8px">
        <a href="index.html" class="btn">MENU</a>
        <button id="btnRestart" class="btn">RESTART</button>
      </div>
    </div>

    <footer>üåÜ Desenvolvido por Jo√£o Henrique ¬© 2025</footer>
  </div>

  <div class="crt"></div>

<script>
/* Flappy Neon ‚Äî HTML5 Canvas
   - F√≠sica semelhante ao Pygame original
   - Futurista neon visual (pr√©dios + parallax + canos neon)
   - Countdown, score, highscore em localStorage
   - Controles: Espa√ßo para flap / Espa√ßo para reiniciar
*/

(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const scoreBox = document.getElementById('scoreBox');
  const btnRestart = document.getElementById('btnRestart');

  // f√≠sica / config (mantidos da vers√£o Pygame)
  const GRAVITY = 0.5;
  const FLAP = -9;
  const PIPE_GAP = 150;
  const PIPE_W = 80;
  const PIPE_INTERVAL = 1600; // ms
  const GROUND_H = 90;
  const BASE_SPEED = 200;

  // estado
  let bird = null;
  let pipes = [];
  let background = null;
  let score = 0;
  let high = parseInt(localStorage.getItem('flappy_high')||0);
  let started = false;
  let gameOver = false;
  let countdown = 0;
  let countdownStart = 0;
  let lastPipeTime = 0;
  let groundOffset = 0;

  scoreBox.textContent = `SCORE: ${score}`;

  // --- utilities ---
  function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  // Bird object
  class Bird {
    constructor(){
      this.x = 80;
      this.y = h/2;
      this.w = 34; this.h = 26;
      this.vel = 0;
      this.rotation = 0;
      this.flapAnim = 0;
    }
    flap(){
      this.vel = FLAP;
    }
    update(applyGravity=true){
      if(applyGravity){
        this.vel += GRAVITY;
        this.y += this.vel;
      }
      if(this.y < 0){ this.y = 0; this.vel = 0; }
      // rotation: negative when going up, positive when falling
      this.rotation = Math.max(-30, Math.min(90, -this.vel * 3));
      this.flapAnim += 1;
    }
    rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }

    draw(ctx){
      // Draw neon bird (futuristic: body + glow + eye)
      ctx.save();
      ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.rotate(this.rotation * Math.PI/180);

      // glow
      ctx.fillStyle = 'rgba(0,234,255,0.07)';
      ctx.beginPath(); ctx.ellipse(0,0,this.w*1.4,this.h*1.2,0,0,Math.PI*2); ctx.fill();

      // body gradient neon
      const g = ctx.createLinearGradient(-this.w/2, -this.h/2, this.w/2, this.h/2);
      g.addColorStop(0, '#00eaff'); g.addColorStop(0.5, '#7a00ff'); g.addColorStop(1, '#ff2dfb');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(0,0,this.w/2,this.h/2,0,0,Math.PI*2); ctx.fill();

      // belly bright
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath(); ctx.ellipse(-2,2,this.w/5,this.h/5,0,0,Math.PI*2); ctx.fill();

      // eye
      ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.w*0.12,-this.h*0.05,3,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.w*0.16,-this.h*0.08,1.2,0,Math.PI*2); ctx.fill();

      // beak
      ctx.fillStyle = '#ff9f00'; ctx.beginPath();
      ctx.moveTo(this.w*0.25, 0); ctx.lineTo(this.w*0.45, -3); ctx.lineTo(this.w*0.25, 3); ctx.closePath(); ctx.fill();

      ctx.restore();
    }
  }

  // Pipe
  class Pipe {
    constructor(x){
      this.x = x;
      this.w = PIPE_W;
      this.gapY = rand(100, h - GROUND_H - PIPE_GAP - 30);
      this.passed = false;
    }
    update(dt){
      this.x -= BASE_SPEED * (dt/1000);
    }
    offScreen(){ return this.x + this.w < 0; }
    collides(rect){
      const top = {x:this.x, y:0, w:this.w, h:this.gapY};
      const bottom = {x:this.x, y:this.gapY + PIPE_GAP, w:this.w, h:h - GROUND_H - (this.gapY + PIPE_GAP)};
      return collideRect(rect, top) || collideRect(rect, bottom);
    }
    draw(ctx){
      // neon pipe style - top
      ctx.fillStyle = '#0b6f3a';
      roundRect(ctx, this.x, 0, this.w, this.gapY, 6, true, false);
      // inner highlight
      ctx.fillStyle = '#00eaff';
      ctx.fillRect(this.x + 6, 6, this.w - 12, Math.max(4, this.gapY - 12));

      // cap
      ctx.fillStyle = '#073f22';
      ctx.fillRect(this.x - 6, this.gapY - 16, this.w + 12, 16);

      // bottom
      const bY = this.gapY + PIPE_GAP;
      ctx.fillStyle = '#0b6f3a';
      roundRect(ctx, this.x, bY, this.w, h - GROUND_H - bY, 6, true, false);
      ctx.fillStyle = '#00eaff';
      ctx.fillRect(this.x + 6, bY + 6, this.w - 12, Math.max(4, h - GROUND_H - bY - 12));
      ctx.fillStyle = '#073f22';
      ctx.fillRect(this.x - 6, bY + (h - GROUND_H - bY) , this.w + 12, 16);
    }
  }

  // Background (parallax city)
  class Background {
    constructor(){
      this.clouds = [];
      this.buildings = [];
      this.init();
    }
    init(){
      for(let i=0;i<4;i++){
        this.clouds.push({x:i*180 + rand(-40,40), y:rand(40,100), w:rand(80,140)});
      }
      let bx = 0;
      while(bx < w + 200){
        const bw = rand(40,80);
        const bh = rand(60,140);
        const tone = rand(40,90);
        this.buildings.push({x:bx + rand(-10,10), w:bw, h:bh, tone});
        bx += rand(80,120);
      }
    }
    update(dt){
      const move = BASE_SPEED * (dt/1000) * 0.6;
      this.clouds.forEach(c => c.x -= move * 0.6);
      this.clouds = this.clouds.filter(c => c.x > -200);
      while(this.clouds.length < 4) this.clouds.push({x:w + rand(80,150), y:rand(40,100), w:rand(80,140)});

      this.buildings.forEach(b => b.x -= move * 0.45);
      this.buildings = this.buildings.filter(b => b.x > -120);
      while(this.buildings.length < 8){
        const lastX = this.buildings.length ? Math.max(...this.buildings.map(p => p.x)) : w;
        const bw = rand(40,80);
        const bh = rand(60,140);
        const tone = rand(40,90);
        this.buildings.push({x:lastX + rand(80,120), w:bw, h:bh, tone});
      }
    }
    draw(ctx){
      // gradient sky
      const sky = ctx.createLinearGradient(0,0,0,h);
      sky.addColorStop(0, '#0a0020');
      sky.addColorStop(0.5, '#1a003a');
      sky.addColorStop(1, '#050014');
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,w,h);

      // neon sun / horizon
      const sunG = ctx.createRadialGradient(w*0.5, h*0.75, 10, w*0.5, h*0.75, 400);
      sunG.addColorStop(0, 'rgba(255,45,251,0.9)');
      sunG.addColorStop(0.2, 'rgba(255,120,150,0.12)');
      sunG.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = sunG;
      ctx.fillRect(0, h*0.45, w, h*0.55);

      // buildings
      for(const b of this.buildings){
        const col = `rgb(${b.tone},${Math.max(0,b.tone-10)},${Math.min(120,b.tone+40)})`;
        ctx.fillStyle = col;
        ctx.fillRect(b.x, h - GROUND_H - b.h, b.w, b.h);

        // windows
        ctx.fillStyle = 'rgba(255,230,120,0.9)';
        for(let y = h - GROUND_H - b.h + 8; y < h - GROUND_H - 10; y += 24){
          for(let x = Math.floor(b.x)+6; x < b.x + b.w - 10; x += 16){
            if(Math.random() < 0.75) ctx.fillRect(x, y, 8, 10);
          }
        }
      }

      // clouds
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for(const c of this.clouds){
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.w, 24, 0, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // helpers
  function collideRect(a,b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
  }

  function roundRect(ctx,x,y,w,h,r,fillFlag=true,strokeFlag=true){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fillFlag) ctx.fill();
    if(strokeFlag) ctx.stroke();
  }

  // init
  function resetGame(initCountdown=false){
    bird = new Bird();
    pipes = [];
    background = new Background();
    score = 0;
    started = false;
    gameOver = false;
    countdown = initCountdown ? 3 : 0;
    countdownStart = 0;
    lastPipeTime = performance.now();
    groundOffset = 0;
    updateScoreUI();
  }

  function updateScoreUI(){
    scoreBox.textContent = `SCORE: ${score}  (BEST: ${high})`;
  }

  // input
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space'){
      // Reinicia imediatamente se game over
      if(gameOver){
        resetGame(true);
        return;
      }

      if(!started){
        countdown = 3; countdownStart = performance.now(); started = true;
      } else if(!gameOver && countdown === 0){
        bird.flap();
      }
    }
    if(e.key === 'Escape'){ window.location.href = 'index.html'; }
  });

  btnRestart.addEventListener('click', ()=> resetGame(true));

  // game loop
  let lastTime = performance.now();
  function loop(now){
    const dt = now - lastTime;
    lastTime = now;

    if(started && countdown === 0 && !gameOver){
      bird.update(true);
      background.update(dt);
      // spawn pipes
      if(now - lastPipeTime > PIPE_INTERVAL){
        pipes.push(new Pipe(w + 20));
        lastPipeTime = now;
      }
      // update pipes
      for(const p of pipes) p.update(dt);
      pipes = pipes.filter(p => !p.offScreen());

      // collisions
      for(const p of pipes){
        if(p.collides(bird.rect())){
          gameOver = true;
        }
        if(!p.passed && p.x + p.w < bird.x){
          p.passed = true;
          score++;
          if(score > high){ high = score; localStorage.setItem('flappy_high', high); }
          updateScoreUI();
        }
      }

      // ground collision
      if(bird.y + bird.h >= h - GROUND_H){
        gameOver = true;
        bird.y = h - GROUND_H - bird.h;
      }

      groundOffset -= BASE_SPEED * (dt/1000);
    } else if(started && countdown > 0){
      // countdown behavior
      bird.update(false);
      if(!countdownStart) countdownStart = now;
      const elapsed = Math.floor((now - countdownStart)/1000);
      if(elapsed >= 1){
        countdown -= 1;
        countdownStart = now;
      }
    } else if(!started){
      bird.update(false);
    }

    // draw
    background.draw(ctx);
    for(const p of pipes) p.draw(ctx);
    // ground
    drawGround(ctx, groundOffset);
    bird.draw(ctx);

    // UI overlays
    drawUI(ctx);

    requestAnimationFrame(loop);
  }

  function drawGround(ctx, offset){
    ctx.fillStyle = '#1c1c1c';
    ctx.fillRect(0, h - GROUND_H, w, GROUND_H);
    ctx.fillStyle = '#888';
    const step = 60;
    for(let i=0;i<w;i+=step){
      ctx.fillRect(i + (offset % step), h - GROUND_H/2, 30, 4);
    }
  }

  function drawUI(ctx){
    // score center
    ctx.fillStyle = '#000';
    ctx.globalAlpha = 0.4;
    roundRect(ctx, w/2 - 64, 12, 128, 40, 8, true, false);
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#00eaff';
    ctx.font = "22px 'Press Start 2P'";
    ctx.textAlign = 'center';
    ctx.fillText(score, w/2, 38);

    // countdown
    if(started && countdown > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      roundRect(ctx, w/2 - 60, h/2 - 40, 120, 80, 10, true, false);
      ctx.fillStyle = '#ff2dfb';
      ctx.font = "48px 'Press Start 2P'";
      ctx.fillText(String(countdown), w/2, h/2 + 10);
    }

    // game over
    if(gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      roundRect(ctx, w/2 - 160, h/2 - 80, 320, 160, 12, true, false);

      ctx.fillStyle = '#ff2dfb';
      ctx.font = "28px 'Press Start 2P'";
      ctx.fillText('GAME OVER!', w/2, h/2 - 20);

      ctx.fillStyle = '#00eaff';
      ctx.font = "14px 'VT323'";
      ctx.fillText(`Score: ${score}   Best: ${high}`, w/2, h/2 + 10);

      ctx.fillStyle = '#fff';
      ctx.font = "12px 'VT323'";
      ctx.fillText('Pressione ESPA√áO para reiniciar', w/2, h/2 + 40);
    }
  }

  // start
  resetGame(false);
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
